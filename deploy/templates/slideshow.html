<!DOCTYPE html>
<html>
<head>
    <title>PiFrame Slideshow</title>
    <meta charset="UTF-8">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 1920px;
            height: 1080px;
            background: #000;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            cursor: none;
        }

        .slideshow-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 1920px;
            height: 1080px;
            background: #000;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 1920px;
            height: 1080px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            opacity: 0;
        }

        .slide.active {
            opacity: 1;
            z-index: 2;
        }

        .slide img {
            width: 1920px;
            height: 1080px;
            object-position: center;
        }
        
        /* Status overlay (optional) */
        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: #fff;
            background: rgba(0,0,0,0.5);
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            opacity: 0;
            transition: opacity 0.3s;
        }
        
        .status.show {
            opacity: 1;
        }

        /* Text overlay styles */
        .text-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 1920px;
            height: 1080px;
            background: transparent;
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            padding: 100px;
        }

        .text-overlay.active {
            display: flex;
        }

        .text-overlay-content {
            color: #fff;
            text-align: center;
            font-weight: bold;
            line-height: 1.4;
            max-width: 100%;
            word-wrap: break-word;
            text-shadow: 4px 4px 8px rgba(0, 0, 0, 0.9);
        }
    </style>
</head>
<body style="margin:0;padding:0;background:#000;width:1920px;height:1080px;overflow:hidden">
    <div class="slideshow-container">
    </div>
    <div class="status" id="status"></div>
    <div class="text-overlay" id="textOverlay">
        <div class="text-overlay-content" id="overlayContent"></div>
    </div>
    
    <script>
        const config = {
            delay: {{ config.delay }} * 1000,
            randomize: {{ 'true' if config.randomize else 'false' }},
            transitionDuration: {{ config.transition_duration }} * 1000,
            stretch: {{ 'true' if config.get('stretch', True) else 'false' }}
        };
        
        let photos = [];
        let currentIndex = 0;
        let slideInterval;
        const container = document.querySelector('.slideshow-container');
        const status = document.getElementById('status');
        
        // Fetch photo list
        async function loadPhotos() {
            try {
                const response = await fetch('/api/photos');
                photos = await response.json();
                
                if (config.randomize) {
                    shuffleArray(photos);
                }
                
                if (photos.length > 0) {
                    initSlideshow();
                } else {
                    showStatus('No photos found');
                }
            } catch (error) {
                showStatus('Error loading photos: ' + error.message);
            }
        }
        
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }
        
        async function initSlideshow() {
            // Preload first three images - wait for first to fully load
            await createSlide(0);

            // Wait a bit to ensure image is rendered
            await new Promise(resolve => setTimeout(resolve, 100));

            // Start loading additional images
            if (photos.length > 1) {
                createSlide(1);
            }
            if (photos.length > 2) {
                createSlide(2);
            }

            // Start slideshow after first image is loaded and rendered
            showSlide(0);
            startSlideshow();
        }
        
        function createSlide(index) {
            const slide = document.createElement('div');
            slide.className = 'slide';
            slide.dataset.index = index;
            // Apply transition duration dynamically
            slide.style.transition = `opacity ${config.transitionDuration / 1000}s ease-in-out`;

            const img = document.createElement('img');
            // Apply stretch mode
            img.style.objectFit = config.stretch ? 'cover' : 'contain';

            // Preload image before adding to DOM
            return new Promise((resolve, reject) => {
                img.onload = () => {
                    slide.appendChild(img);
                    container.appendChild(slide);
                    resolve(slide);
                };
                img.onerror = () => {
                    console.error('Failed to load image:', photos[index]);
                    reject();
                };
                img.src = `/photos/${encodeURIComponent(photos[index])}`;
            });
        }
        
        async function showSlide(index) {
            // Get the new slide (create if needed)
            let slide = container.querySelector(`[data-index="${index}"]`);
            if (!slide) {
                slide = await createSlide(index);
            }

            const slides = container.querySelectorAll('.slide');

            // Step 1: Fade out current slide to black
            slides.forEach(s => {
                if (s.classList.contains('active')) {
                    s.classList.remove('active');
                }
            });

            // Step 2: Wait for fade-out to complete, then fade in new slide
            await new Promise(resolve => setTimeout(resolve, config.transitionDuration));

            slide.classList.add('active');
            currentIndex = index;

            // After fade-in completes, cleanup old slides
            setTimeout(() => {
                slides.forEach(s => {
                    if (s !== slide) {
                        s.classList.remove('active');
                    }
                });
            }, config.transitionDuration);

            // Preload next two images
            const nextIndex = (index + 1) % photos.length;
            const nextNextIndex = (index + 2) % photos.length;

            if (!container.querySelector(`[data-index="${nextIndex}"]`)) {
                createSlide(nextIndex);
            }
            if (!container.querySelector(`[data-index="${nextNextIndex}"]`)) {
                createSlide(nextNextIndex);
            }

            // When near the end, preload first images for smooth loop
            if (index >= photos.length - 3) {
                for (let i = 0; i < 3; i++) {
                    if (!container.querySelector(`[data-index="${i}"]`)) {
                        createSlide(i);
                    }
                }
            }
        }
        
        function nextSlide() {
            showSlide((currentIndex + 1) % photos.length);
        }

        function startSlideshow() {
            if (slideInterval) {
                clearInterval(slideInterval);
            }
            slideInterval = setInterval(nextSlide, config.delay);
        }

        function showStatus(message) {
            status.textContent = message;
            status.classList.add('show');
            setTimeout(() => status.classList.remove('show'), 3000);
        }

        // Text overlay management
        async function checkOverlay() {
            try {
                const response = await fetch('/api/overlay');
                const data = await response.json();

                if (!data.text) {
                    document.getElementById('textOverlay').classList.remove('active');
                    return;
                }

                // Check if we should display based on schedule
                const now = new Date();
                const currentTime = now.getHours() * 60 + now.getMinutes();

                let shouldDisplay = true;

                if (data.startTime && data.endTime) {
                    const [startH, startM] = data.startTime.split(':').map(Number);
                    const [endH, endM] = data.endTime.split(':').map(Number);
                    const startMinutes = startH * 60 + startM;
                    const endMinutes = endH * 60 + endM;

                    if (startMinutes <= endMinutes) {
                        // Normal case: start and end on same day
                        shouldDisplay = currentTime >= startMinutes && currentTime <= endMinutes;
                    } else {
                        // Crosses midnight
                        shouldDisplay = currentTime >= startMinutes || currentTime <= endMinutes;
                    }
                }

                if (shouldDisplay) {
                    // Auto-size font based on text length
                    const textLength = data.text.length;
                    let fontSize;
                    if (textLength < 50) {
                        fontSize = '120px';
                    } else if (textLength < 100) {
                        fontSize = '90px';
                    } else if (textLength < 200) {
                        fontSize = '70px';
                    } else if (textLength < 400) {
                        fontSize = '50px';
                    } else {
                        fontSize = '35px';
                    }

                    const content = document.getElementById('overlayContent');
                    content.textContent = data.text;
                    content.style.fontSize = fontSize;
                    document.getElementById('textOverlay').classList.add('active');
                } else {
                    document.getElementById('textOverlay').classList.remove('active');
                }
            } catch (error) {
                console.error('Failed to check overlay:', error);
            }
        }

        // Cleanup old slides to prevent memory leak - keep more slides cached
        function cleanupSlides() {
            const slides = container.querySelectorAll('.slide');
            if (slides.length > 8) {
                slides.forEach((slide) => {
                    const slideIndex = parseInt(slide.dataset.index);
                    const currentIdx = currentIndex;
                    const nextIdx = (currentIndex + 1) % photos.length;
                    const nextNextIdx = (currentIndex + 2) % photos.length;

                    // Always keep first 3 slides for smooth looping
                    if (slideIndex < 3) {
                        return;
                    }

                    // Keep current and next 2 slides
                    if (slideIndex !== currentIdx &&
                        slideIndex !== nextIdx &&
                        slideIndex !== nextNextIdx &&
                        !slide.classList.contains('active')) {
                        slide.remove();
                    }
                });
            }
        }

        // Clean up every 3 minutes
        setInterval(cleanupSlides, 180000);

        // Check for config updates and apply them live
        async function checkConfigUpdates() {
            try {
                const response = await fetch('/api/config');
                const newConfig = await response.json();

                // Update delay if changed
                if (newConfig.delay * 1000 !== config.delay) {
                    config.delay = newConfig.delay * 1000;
                    startSlideshow(); // Restart interval with new delay
                }

                // Update transition duration if changed
                if (newConfig.transition_duration * 1000 !== config.transitionDuration) {
                    config.transitionDuration = newConfig.transition_duration * 1000;
                    // Update all existing slides with new transition
                    const slides = container.querySelectorAll('.slide');
                    slides.forEach(slide => {
                        slide.style.transition = `opacity ${config.transitionDuration / 1000}s ease-in-out`;
                    });
                }

                // Update stretch mode if changed
                if (newConfig.stretch !== config.stretch) {
                    config.stretch = newConfig.stretch;
                    const images = container.querySelectorAll('.slide img');
                    images.forEach(img => {
                        img.style.objectFit = config.stretch ? 'cover' : 'contain';
                    });
                }
            } catch (error) {
                console.error('Failed to check config updates:', error);
            }
        }

        // Check for config updates every 5 seconds
        setInterval(checkConfigUpdates, 5000);

        // Check overlay every 5 seconds
        setInterval(checkOverlay, 5000);
        checkOverlay(); // Check immediately on load

        // Initialize on page load
        loadPhotos();
    </script>
</body>
</html>